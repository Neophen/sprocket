// import * as App from "app";
import morphdom from "morphdom";

function attachEventHandlers(socket) {
  document.querySelectorAll("[live-event]").forEach((el) => {
    let [event, id] = el.attributes["live-event"].value.split("=");

    el.addEventListener(event, (e) => {
      socket.send(JSON.stringify({ event, id }));
    });
  });
}

window.addEventListener("DOMContentLoaded", () => {
  // App.main();

  const socket = new WebSocket("ws://localhost:3000/live");

  let dom = null;

  socket.addEventListener("open", function (event) {
    console.log("ws opened on browser");
    socket.send(["join"]);
  });
  socket.addEventListener("message", function (event) {
    console.log("Message from server ", event.data);

    let parsed = JSON.parse(event.data);

    if (Array.isArray(parsed)) {
      switch (parsed[0]) {
        case "update":
          console.log("updating body with: ", parsed[1]);

          dom = parsed[1];
          // if (dom === null) {
          //   dom = parsed[1];
          // } else {
          //   dom = patchDom(dom, parsed[1]);
          // }

          console.log("dom: ", dom);

          let rendered = renderDom(dom);

          console.log("rendered: ", rendered);

          let body = document.querySelector("body");
          morphdom(body, rendered);

          attachEventHandlers(socket);
      }
    }
  });

  // wire up event handlers
  attachEventHandlers(socket);
});

// // some wild diffing algorithm generated by copilot, probably incorrect
// function patchDom(d1, d2) {
//   if (d1.type !== d2.type) {
//     return d2;
//   }

//   if (typeof d2 === "string") {
//     return d2;
//   }

//   let newDom = {
//     type: d1.type,
//     attrs: {},
//   };

//   for (let key in d1.attrs) {
//     if (d1.attrs[key] !== d2.attrs[key]) {
//       newDom.attrs[key] = d2.attrs[key];
//     }
//   }

//   for (let key in d2.attributes) {
//     if (d1.attributes[key] === undefined) {
//       newDom.attributes[key] = d2.attributes[key];
//     }
//   }

//   if (d1.type === "component") {
//     for (let i = 0; i < Object.keys(d2).length - 1; i++) {
//       newDom[i] = patchDom(d1[i], d2[i]);
//     }
//   } else {
//     for (let i = 0; i < Object.keys(d2).length - 2; i++) {
//       newDom[i] = patchDom(d1[i], d2[i]);
//     }
//   }

//   return newDom;
// }

// very naive and basic rendering algorithm
// TODO: rewrite to a more readable approach
function renderDom(dom) {
  if (typeof dom === "string") {
    return dom;
  }

  switch (dom.type) {
    case "component":
      return renderComponent(dom);
    default:
      return renderElement(dom);
  }
}

function renderComponent(component) {
  let result = "";
  for (let i = 0; i < Object.keys(component).length - 1; i++) {
    result += renderDom(component[i]);
  }

  return result;
}

function renderElement(element) {
  let result = "";

  result += `<${element.type}`;
  result += Object.keys(element.attrs).map((key) => {
    return ` ${key}="${element.attrs[key]}"`;
  });
  result += ">";

  for (let i = 0; i < Object.keys(element).length - 2; i++) {
    result += renderDom(element[i]);
  }

  result += "</" + element.type + ">";

  return result;
}
